```python
#!/usr/bin/env python3

# gripper_control.py

#

# - close_until_contact: motor_control.STEP_CONTROL.tighten_until() で締め続け、CONTACTで停止

# - push_after_contact: CONTACT停止後に weak/mid/strong の押し込み（相対パルス）を追加実行

# - stop_close: close/push の両方を停止

#

# 前提:

# motor_control.py の STEP_CONTROL に tighten_until(stop_check, rpm, step, ...) が実装済み

# 例: 以前提示した tighten_until を追加済みであること

#

#改良版

#`ros2 run gripper_control gripper_control --ros-args -p stop_on_contact:=true`

  

#ゼロ合わせ（任意）：

  

#`ros2 service call /gripper/set_zero std_srvs/srv/Empty {}`

  

#締め続け開始（CONTACTで止まる）：

  

#`ros2 service call /gripper/close_until_contact std_srvs/srv/Trigger`

  

#手動停止：

  

#`ros2 service call /gripper/stop_close std_srvs/srv/Trigger`

################################################################################################

  

import threading

import time

  

import rclpy

from rclpy.node import Node

  

from .motor_control import STEP_CONTROL

  

from std_msgs.msg import Int32, Float32, String

from std_srvs.srv import Empty, Trigger

  

from scipy.interpolate import InterpolatedUnivariateSpline

  
  
  

class GripperControl(Node):

def __init__(self):

super().__init__('gripper_control')

  

# ----------------------------

# Parameters

# ----------------------------

self.com_port = str(self.declare_parameter("com_port", "/dev/ttyUSB_Gripper").value)

self.baudrate = int(self.declare_parameter("baudrate", 9600).value)

  

# moveToEncoder settings

self.speed = int(self.declare_parameter("speed", 10).value)

self.cmd_timeout = int(self.declare_parameter("cmd_timeout", 10).value)

self.encoder_tolerance = int(self.declare_parameter("encoder_tolerance", 50).value)

self.encoder_per_pulse = float(self.declare_parameter("encoder_per_pulse", 20.09).value)

  

# contact

self.stop_on_contact = bool(self.declare_parameter("stop_on_contact", False).value)

self.contact_state_topic = str(self.declare_parameter("contact_state_topic", "/tactile/contact_state").value)

self._prev_contact_state = None

self.subscription_contact_state = None

  

# start-up behavior

self.move_to_mm_max_on_start = bool(self.declare_parameter("move_to_mm_max_on_start", False).value)

  

# close-until-contact settings (delegated to motor_control.tighten_until)

self.close_speed = int(self.declare_parameter("close_speed", 10).value) # rpm

self.close_step_pulses = int(self.declare_parameter("close_step_pulses", 2).value) # pulses per command

self.close_direction = int(self.declare_parameter("close_direction", 1).value) # +1/-1 (閉じ方向)

self.close_max_pulses = int(self.declare_parameter("close_max_pulses", 900).value) # safety (abs sum)

self.close_sleep_margin_s = float(self.declare_parameter("close_sleep_margin_s", 0.002).value)

  

# setZero settings

self.set_zero_step = int(self.declare_parameter("set_zero_step", 50).value)

self.set_zero_rpm = int(self.declare_parameter("set_zero_rpm", 10).value)

  

# ----------------------------

# Push-after-contact settings

# ----------------------------

self.auto_push_after_contact = bool(self.declare_parameter("auto_push_after_contact", False).value)

self.push_strength = str(self.declare_parameter("push_strength", "weak").value) # weak/mid/strong

  

self.push_rpm = int(self.declare_parameter("push_rpm", 10).value)

self.push_weak_pulses = int(self.declare_parameter("push_weak_pulses", 20).value)

self.push_mid_pulses = int(self.declare_parameter("push_mid_pulses", 40).value)

self.push_strong_pulses = int(self.declare_parameter("push_strong_pulses", 60).value)

  

# safety clamp for push

self.push_max_pulses = int(self.declare_parameter("push_max_pulses", 200).value)

self.push_sleep_margin_s = float(self.declare_parameter("push_sleep_margin_s", 0.01).value)

  

# ----------------------------

# Internal state

# ----------------------------

self._closing_active = False

self._pushing_active = False

self._contacted = False

  

# IMPORTANT: close/push で Event を分離する（CONTACT後のpushが即returnしないため）

self._close_stop_event = threading.Event()

self._push_stop_event = threading.Event()

  

self._close_thread = None

self._push_thread = None

  

# ----------------------------

# ROS I/F: Subscriptions

# ----------------------------

self.subscription_encoder = self.create_subscription(

Int32,

'gripper/gripper_pose_in_encoder',

self.gripperPoseInEncoderCallback,

10

)

  

self.subscription_mm = self.create_subscription(

Float32,

'gripper/gripper_pose_in_mm',

self.gripperPoseInMMCallback,

10

)

  

# ----------------------------

# ROS I/F: Services

# ----------------------------

self.srv_set_zero = self.create_service(Empty, 'gripper/set_zero', self.setZeroCallBack)

self.srv_read_encoder = self.create_service(Trigger, 'gripper/read_encoder', self.readEncoderCallback)

  

# close until contact

self.srv_close_until_contact = self.create_service(

Trigger, 'gripper/close_until_contact', self.closeUntilContactCallback

)

self.srv_stop_close = self.create_service(

Trigger, 'gripper/stop_close', self.stopCloseCallback

)

  

# manual push services

self.srv_push_weak = self.create_service(Trigger, 'gripper/push_weak', self.pushWeakCallback)

self.srv_push_mid = self.create_service(Trigger, 'gripper/push_mid', self.pushMidCallback)

self.srv_push_strong = self.create_service(Trigger, 'gripper/push_strong', self.pushStrongCallback)

  

# ----------------------------

# Motor control init

# ----------------------------

self.step_control = STEP_CONTROL(com_port=self.com_port, baudrate=self.baudrate)

self.open()

  

# Print motor status

self.get_logger().info(f'encoder value: {self.step_control.readEncoderValue()}')

self.get_logger().info(f'Pulse received: {self.step_control.readReceivedPulses()}')

self.get_logger().info(f'Motor angle: {self.step_control.readMotorShaftAngle()}')

self.get_logger().info(f'error: {self.step_control.readMotorShaftErrorAngle()}')

self.get_logger().info(f'en pin: {self.step_control.readEnPinStatus()}')

self.get_logger().info(f'shaft status: {self.step_control.readShaftStatus()}')

  

if self.stop_on_contact:

self._ensure_contact_subscription()

self.get_logger().info(f"Stop on CONTACT enabled: {self.contact_state_topic}")

  

# ----------------------------

# Calibration (mm -> encoder)

# ----------------------------

x = [10.0, 21.0, 38.3, 51.6, 68.0]

y = [35284, 33111, 25747, 23709, 21218]

k = min(3, len(x) - 1)

self.mm2encoder_gripper = InterpolatedUnivariateSpline(x, y, k=k, check_finite=False)

  

self.encoder_min = 21218 # OPEN

self.encoder_max = 35284 # CLOSE

self.mm_min = 10.0

self.mm_max = 68.0

  

if self.move_to_mm_max_on_start:

self.get_logger().info("起動時にmm_maxへ移動します（ゼロ位置調整）")

self._move_to_mm(self.mm_max)

  

# ----------------------------

# Helpers

# ----------------------------

def _ensure_contact_subscription(self):

if self.subscription_contact_state is None:

self.subscription_contact_state = self.create_subscription(

String,

self.contact_state_topic,

self.contactStateCallback,

10

)

  

def open(self):

ret = self.step_control.open()

if not ret:

raise RuntimeError("Com Port Error: cannot open motor controller")

self.get_logger().info(f'En pin: {self.step_control.setEnablePin(True)}')

  

def _stop_all_motion(self, reason: str):

if self._closing_active or self._pushing_active:

self.get_logger().info(f"Stopping motion: {reason}")

  

# stop flags

self._close_stop_event.set()

self._push_stop_event.set()

  

# motor stop

self.step_control.stopMotor()

  

self._closing_active = False

self._pushing_active = False

  

def _strength_to_pulses(self, strength: str) -> int:

s = (strength or "").strip().lower()

if s == "weak":

return self.push_weak_pulses

if s == "mid":

return self.push_mid_pulses

if s == "strong":

return self.push_strong_pulses

return self.push_weak_pulses

  

# ----------------------------

# Services

# ----------------------------

def readEncoderCallback(self, request, response):

value, ret = self.step_control.readEncoderValue()

if ret == 1:

response.success = True

response.message = str(value)

else:

response.success = False

response.message = "Failed to read encoder"

return response

  

def setZeroCallBack(self, request, response):

# 競合回避：動作中は止めてから実施

if self._closing_active or self._pushing_active:

self._stop_all_motion("set_zero called during motion")

  

self.get_logger().info(f"Set Zero: {self.step_control.setZero(self.set_zero_step, self.set_zero_rpm)}")

self.get_logger().info(f'encoder value: {self.step_control.readEncoderValue()}')

return response

  

def closeUntilContactCallback(self, request, response):

# close_until_contact は contact 監視が必須

if not self.stop_on_contact:

self.stop_on_contact = True

self._ensure_contact_subscription()

self.get_logger().info(f"Stop on CONTACT enabled (auto): {self.contact_state_topic}")

  

if self._closing_active:

response.success = True

response.message = "Already closing."

return response

  

# 既存動作があれば停止してから開始

if self._pushing_active:

self._stop_all_motion("start close_until_contact while pushing")

  

self._closing_active = True

self._contacted = False

  

# close 停止フラグは clear して開始

self._close_stop_event.clear()

  

signed_step = int(self.close_direction * self.close_step_pulses)

if signed_step == 0:

self._closing_active = False

response.success = False

response.message = "close_step_pulses is 0."

return response

  

self.get_logger().info(

f"close_until_contact start: rpm={self.close_speed}, step={signed_step}, "

f"max_abs_pulses={self.close_max_pulses}, margin={self.close_sleep_margin_s}s"

)

  

self._close_thread = threading.Thread(

target=self._close_worker,

args=(self.close_speed, signed_step, self.close_max_pulses, self.close_sleep_margin_s),

daemon=True

)

self._close_thread.start()

  

response.success = True

response.message = "Started closing until contact."

return response

  

def stopCloseCallback(self, request, response):

self._stop_all_motion("manual stop_close")

response.success = True

response.message = "Stopped."

return response

  

def pushWeakCallback(self, request, response):

ok, msg = self._start_push("weak")

response.success = bool(ok)

response.message = msg

return response

  

def pushMidCallback(self, request, response):

ok, msg = self._start_push("mid")

response.success = bool(ok)

response.message = msg

return response

  

def pushStrongCallback(self, request, response):

ok, msg = self._start_push("strong")

response.success = bool(ok)

response.message = msg

return response

  

# ----------------------------

# Workers

# ----------------------------

def _close_worker(self, rpm: int, step: int, max_pulses: int, margin_s: float):

try:

ret = self.step_control.tighten_until(

stop_check=self._close_stop_event.is_set,

rpm=rpm,

step=step,

max_abs_pulses=max_pulses,

sleep_margin_s=margin_s,

)

  

if ret == 1:

self.get_logger().info("close worker finished: stop flag/contact")

elif ret == 0:

self.get_logger().warn("close worker finished: reached max pulses (safety stop)")

else:

self.get_logger().warn(f"close worker finished: error ret={ret}")

finally:

self._closing_active = False

  

def _start_push(self, strength: str):

if self._pushing_active:

return True, "Already pushing."

  

pulses = self._strength_to_pulses(strength)

pulses = int(max(0, min(int(pulses), int(self.push_max_pulses))))

if pulses == 0:

return False, "Push pulses is 0 (after clamp)."

  

signed_pulses = int(self.close_direction * pulses)

  

# push 停止フラグは clear して開始（CONTACTでcloseを止めてもpushが止まらない）

self._push_stop_event.clear()

self._pushing_active = True

  

self.get_logger().info(

f"push start: strength={strength}, rpm={self.push_rpm}, pulses={signed_pulses} "

f"(max={self.push_max_pulses})"

)

  

self._push_thread = threading.Thread(

target=self._push_worker,

args=(self.push_rpm, signed_pulses),

daemon=True

)

self._push_thread.start()

return True, "Push started."

  

def _push_worker(self, rpm: int, signed_pulses: int):

try:

if self._push_stop_event.is_set():

return

  

# 念のため enable

self.step_control.setEnablePin(True)

  

ret = self.step_control.setMotorRelativePose(rpm, signed_pulses)

if ret != 1:

self.get_logger().warn(f"push failed: setMotorRelativePose ret={ret}")

return

  

# 目安時間（途中停止可能なように分割sleep）

dt = float(self.step_control.calDelayTime(rpm, signed_pulses)) + float(self.push_sleep_margin_s)

end_t = time.time() + max(0.0, dt)

  

while time.time() < end_t:

if self._push_stop_event.is_set():

self.step_control.stopMotor()

self.get_logger().info("push interrupted by stop event")

return

time.sleep(0.01)

  

finally:

self._pushing_active = False

self.get_logger().info("push finished")

  

# ----------------------------

# Topic callbacks

# ----------------------------

def gripperPoseInMMCallback(self, data):

if self._closing_active or self._pushing_active:

self.get_logger().warn("Ignoring mm command while motion is active.")

return

self._move_to_mm(float(data.data))

  

def _move_to_mm(self, target_mm: float):

target_mm = max(self.mm_min, min(target_mm, self.mm_max))

target_encoder = int(self.mm2encoder_gripper(target_mm))

target_encoder = max(self.encoder_min, min(target_encoder, self.encoder_max))

  

self.get_logger().info(f"目標: {target_mm}mm → encoder {target_encoder}")

self.moveToEncoder(target_encoder)

  

def gripperPoseInEncoderCallback(self, data):

if self._closing_active or self._pushing_active:

self.get_logger().warn("Ignoring encoder command while motion is active.")

return

target_encoder = max(self.encoder_min, min(int(data.data), self.encoder_max))

self.get_logger().info(f"目標エンコーダ: {target_encoder}")

self.moveToEncoder(target_encoder)

  

def contactStateCallback(self, msg: String):

state = msg.data.strip()

if state == "CONTACT" and self._prev_contact_state != "CONTACT":

self._contacted = True

  

# close worker 停止（closeだけ止める。pushは別Event）

self._close_stop_event.set()

  

# 即停止（慣性や通信遅延の吸収）

ret = self.step_control.stopMotor()

if ret == 1:

self.get_logger().info("CONTACT検出: stopMotor送信")

else:

self.get_logger().warn(f"CONTACT検出: stopMotor失敗 (ret={ret})")

  

self._closing_active = False

  

# CONTACT後 自動押し込み

if self.auto_push_after_contact:

ok, msg2 = self._start_push(self.push_strength)

if not ok:

self.get_logger().warn(f"auto push skipped: {msg2}")

  

self._prev_contact_state = state

  

# ----------------------------

# Absolute move (kept)

# ----------------------------

def moveToEncoder(self, target_encoder: int):

current_encoder, ret = self.step_control.readEncoderValue()

if ret != 1:

self.get_logger().error("エンコーダ値の読み取りに失敗")

return

  

self.get_logger().info(f"現在: {current_encoder}, 目標: {target_encoder}")

  

diff = target_encoder - current_encoder

if abs(diff) < self.encoder_tolerance:

self.get_logger().info("すでに目標位置にいます")

return

  

step_to_move = int(diff / self.encoder_per_pulse)

self.get_logger().info(f"移動量: encoder {diff} → step(pulses) {step_to_move}")

  

current_pulses, ret = self.step_control.readReceivedPulses()

if ret != 1:

self.get_logger().error("パルス値の読み取りに失敗")

return

  

target_pulses = current_pulses + step_to_move

  

for attempt in range(self.cmd_timeout):

ret = self.step_control.setMotorAbsolutePose(self.speed, target_pulses)

if ret == 1:

self.get_logger().info(f"移動コマンド送信成功 (target pulses: {target_pulses})")

break

self.get_logger().warn(f"移動コマンド送信失敗 (試行 {attempt + 1})")

  

# ----------------------------

# Main loop

# ----------------------------

def process(self):

try:

while rclpy.ok():

rclpy.spin_once(self, timeout_sec=0.01)

except KeyboardInterrupt:

pass

finally:

self._stop_all_motion("shutdown")

self.step_control.close()

self.get_logger().info("Serial connection closed")

  
  

def main(args=None):

rclpy.init(args=args)

node = GripperControl()

node.process()

node.destroy_node()

rclpy.shutdown()

  
  

if __name__ == '__main__':

main()
```

# 実験
## 1. マシュマロの変位
- 円柱形状
- 球状

|     | Pillar before | Pillar After | Ball Before | Ball After |     |
| --- | ------------- | ------------ | ----------- | ---------- | --- |
| 1   | 28.71         | 21.10        | 25.88       | 18.47      |     |
| 2   | 26.58         | 19.59        | 25.36       | 18.65      |     |
| 3   | 26.17         | 20.84        | 23.60       | 17.67      |     |
| 4   | 25.80         | 19.95        | 24.56       | 18.32      |     |
| 5   | 28.40         | 18.73        | 23.24       | 17.36      |     |
|     | 26.33         | 22.11        | 23.08       | 17.14      |     |
|     | 29.20         | 20.22        | 23.67       | 18.71      |     |
|     | 26.98         | 23.25        | 22.00       | 18.07      |     |
|     | 25.78         | 22.97        | 25.03       | 18.15      |     |
|     | 25.39         | 21.57        | 23.38       | 19.10      |     |
|     |               |              |             |            |     |



## 2. 様々な物体での変位
5回トライアル
- sponge

|     | before | after |
| --- | ------ | ----- |
|     | 30.34  | 27.57 |
|     | 29.60  | 23.55 |
|     | 29.12  | 23.77 |
|     | 29.96  | 26.95 |
|     | 29.00  | 23.87 |

- 紙コップ

|     | before | after |
| --- | ------ | ----- |
|     | 67.27  | 54.68 |
|     | 66.36  | 50.09 |
|     | 65.13  | 54.67 |
|     | 66.87  | 54.29 |
|     | 66.26  | 52.81 |
- いちご

|     | before | after |
| --- | ------ | ----- |
|     | 33.08  | 27.76 |
|     | 30.86  | 29.09 |
|     | 31.26  | 30.08 |
|     | 32.16  | 30.30 |
|     | 31.84  | 29.69 |

- ミニトマト

|     | before | after |
| --- | ------ | ----- |
|     | 24.48  | 22.59 |
|     | 24.27  | 23.23 |
|     | 24.66  | 21.47 |
|     | 24.60  | 21.46 |
|     | 24.07  | 21.25 |


